package com.geekbo.training.leetcode.codeinterview109;


/**
 * 面试题 16.03. 交点
 * 困难
 * 给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。
 * <p>
 * 要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。
 * <p>
 * <p>
 * <p>
 * 示例 1：
 * <p>
 * 输入：
 * line1 = {0, 0}, {1, 0}
 * line2 = {1, 1}, {0, -1}
 * 输出： {0.5, 0}
 * 示例 2：
 * <p>
 * 输入：
 * line1 = {0, 0}, {3, 3}
 * line2 = {1, 1}, {2, 2}
 * 输出： {1, 1}
 * 示例 3：
 * <p>
 * 输入：
 * line1 = {0, 0}, {1, 1}
 * line2 = {1, 0}, {2, 1}
 * 输出： {}，两条线段没有交点
 * <p>
 * <p>
 * 提示：
 * <p>
 * 坐标绝对值不会超过 2^7
 * 输入的坐标均是有效的二维坐标
 * <p>
 * 这是一道计算两条线段交点的问题。可以使用数学方法来解决。
 * <p>
 * 首先，你需要判断两条线段是否相交。可以使用线段相交的条件来判断：
 * <p>
 * 两条线段的起点和终点不在同一侧，即线段1的起点在线段2的一侧，线段1的终点在线段2的另一侧，或者反过来。
 * 两条线段的斜率不相等。
 * 如果两条线段相交，你可以计算它们的交点。交点的计算可以使用参数方程来表示。具体步骤如下：
 * <p>
 * 计算两条线段的斜率：k1 = (Y2 - Y1) / (X2 - X1) 和 k2 = (Y4 - Y3) / (X4 - X3)。
 * 计算两条线段的截距：b1 = Y1 - k1 * X1 和 b2 = Y3 - k2 * X3。
 * 计算交点的 X 坐标：X = (b2 - b1) / (k1 - k2)。
 * 计算交点的 Y 坐标：Y = k1 * X + b1。
 * 最后，根据题目要求选择返回的交点：如果有多个交点，则返回 X 值最小的点，如果 X 值相同，则返回 Y 值最小的点。
 */
public class IntersectionPoint {

    /**
     *
     * 这是一道计算两条线段交点的问题。可以使用数学方法来解决。
     * <p>
     * 首先，你需要判断两条线段是否相交。可以使用线段相交的条件来判断：
     * <p>
     * 两条线段的起点和终点不在同一侧，即线段1的起点在线段2的一侧，线段1的终点在线段2的另一侧，或者反过来。
     * 两条线段的斜率不相等。
     * 如果两条线段相交，你可以计算它们的交点。交点的计算可以使用参数方程来表示。具体步骤如下：
     * <p>
     * 计算两条线段的斜率：k1 = (Y2 - Y1) / (X2 - X1) 和 k2 = (Y4 - Y3) / (X4 - X3)。
     * 计算两条线段的截距：b1 = Y1 - k1 * X1 和 b2 = Y3 - k2 * X3。
     * 计算交点的 X 坐标：X = (b2 - b1) / (k1 - k2)。
     * 计算交点的 Y 坐标：Y = k1 * X + b1。
     * 最后，根据题目要求选择返回的交点：如果有多个交点，则返回 X 值最小的点，如果 X 值相同，则返回 Y 值最小的点。
     */
    double[] ans = new double[0];

    public double[] intersection(int[] start1, int[] end1, int[] start2, int[] end2) {
        int x1 = start1[0], y1 = start1[1];
        int x2 = end1[0], y2 = end1[1];
        int x3 = start2[0], y3 = start2[1];
        int x4 = end2[0], y4 = end2[1];

        // 判断 (x1, y1)~(x2, y2) 和 (x3, y3)~(x4, y4) 是否平行
        if ((y4 - y3) * (x2 - x1) == (y2 - y1) * (x4 - x3)) {
            // 若平行，则判断 (x3, y3) 是否在「直线」(x1, y1)~(x2, y2) 上
            if ((y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)) {
                // 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上
                if (inside(x1, y1, x2, y2, x3, y3)) {
                    update(x3, y3);
                }
                // 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上
                if (inside(x1, y1, x2, y2, x4, y4)) {
                    update(x4, y4);
                }
                // 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上
                if (inside(x3, y3, x4, y4, x1, y1)) {
                    update(x1, y1);
                }
                // 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上
                if (inside(x3, y3, x4, y4, x2, y2)) {
                    update(x2, y2);
                }
            }
            // 在平行时，其余的所有情况都不会有交点
        } else {
            // 联立方程得到 t1 和 t2 的值
            double t1 = (double) (x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1));
            double t2 = (double) (x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3));
            // 判断 t1 和 t2 是否均在 [0, 1] 之间
            if (t1 >= 0.0 && t1 <= 1.0 && t2 >= 0.0 && t2 <= 1.0) {
                ans = new double[]{x1 + t1 * (x2 - x1), y1 + t1 * (y2 - y1)};
            }
        }
        return ans;
    }

    // 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上
    // 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上
    public boolean inside(int x1, int y1, int x2, int y2, int xk, int yk) {
        // 若与 x 轴平行，只需要判断 x 的部分
        // 若与 y 轴平行，只需要判断 y 的部分
        // 若为普通线段，则都要判断
        return (x1 == x2 || (Math.min(x1, x2) <= xk && xk <= Math.max(x1, x2))) && (y1 == y2 || (Math.min(y1, y2) <= yk && yk <= Math.max(y1, y2)));
    }

    public void update(double xk, double yk) {
        // 将一个交点与当前 ans 中的结果进行比较
        // 若更优则替换
        if (ans.length == 0 || xk < ans[0] || (xk == ans[0] && yk < ans[1])) {
            ans = new double[]{xk, yk};
        }
    }

}